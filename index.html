<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Transcription</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 800px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .main-card {
            width: 100%;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .orb-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .info-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .orb {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .orb[data-state="inactive"] {
            background: #e0e0e0;
        }

        .orb[data-state="active"] {
            background: #4ade80;
            box-shadow: 0 0 20px 10px rgba(74, 222, 128, 0.3);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        .orb[data-state="muted"] {
            background: #f5576c;
            box-shadow: 0 0 20px 10px rgba(245, 87, 108, 0.3);
            animation: pulse-glow-red 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 20px 10px rgba(74, 222, 128, 0.3);
            }
            50% {
                box-shadow: 0 0 40px 20px rgba(74, 222, 128, 0.5);
            }
        }

        @keyframes pulse-glow-red {
            0%, 100% {
                box-shadow: 0 0 20px 10px rgba(245, 87, 108, 0.3);
            }
            50% {
                box-shadow: 0 0 40px 20px rgba(245, 87, 108, 0.5);
            }
        }

        .waveform-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .waveform-bar {
            width: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
            transition: height 0.1s ease;
        }

        .mic-icon {
            width: 80px;
            height: 80px;
            position: relative;
            z-index: 10;
        }

        .orb[data-state="muted"] .mic-icon {
            filter: grayscale(100%);
        }

        .orb[data-state="muted"] .mic-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10%;
            right: -10%;
            height: 3px;
            background: #f5576c;
            transform: translateY(-50%) rotate(-45deg);
        }

        .metadata {
            text-align: center;
            color: #333;
            font-size: 0.95em;
            font-weight: 500;
        }

        .status-message {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            min-height: 20px;
        }

        .transcription {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 30px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            width: 100%;
            font-size: 1.1em;
            line-height: 1.8;
            color: white;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
        }

        .transcription.empty {
            color: #666;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .permission-prompt {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .permission-prompt h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .permission-prompt p {
            color: #666;
            margin-bottom: 25px;
        }

        .permission-prompt button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .permission-prompt button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .error-message {
            background: #fff0f0;
            color: #f5576c;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            .orb {
                width: 180px;
                height: 180px;
            }

            .mic-icon {
                width: 60px;
                height: 60px;
            }

            .transcription {
                padding: 20px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <div id="mainApp" class="main-card">
            <div class="orb-container">
                <div class="orb" id="orb" data-state="inactive" tabindex="0" role="button" aria-label="Click to start recording">
                    <div class="waveform-container" id="waveformContainer">
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                        <div class="waveform-bar"></div>
                    </div>
                    <svg class="mic-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </div>
            </div>

            <div class="info-row">
                <div class="metadata" id="metadata">Language: -- • 0.00s</div>
                <div class="status-message" id="statusMessage"></div>
            </div>

            <div class="transcription empty" id="transcription">
                Speak to start transcribing...
            </div>
        </div>

        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        let mediaRecorder;
        let isRecording = false;
        let isMuted = false;
        let chunkCounter = 0;
        let sessionId = null;
        let mediaStream = null;
        let audioContext = null;
        let analyser = null;
        let animationFrameId = null;
        let accumulatedChunks = [];
        let isInitialized = false;

        const orb = document.getElementById('orb');
        const transcription = document.getElementById('transcription');
        const metadata = document.getElementById('metadata');
        const statusMessage = document.getElementById('statusMessage');
        const waveformBars = document.querySelectorAll('.waveform-bar');
        const errorMessage = document.getElementById('errorMessage');

        const VOICE_THRESHOLD = 10;

        async function requestMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                await initializeApp(stream);
                isInitialized = true;
            } catch (error) {
                console.error('Microphone permission denied:', error);
                showError('Microphone access denied. Please grant permission to use this app.');
            }
        }

        async function initializeApp(stream) {
            mediaStream = stream;
            sessionId = Date.now().toString();

            initializeWaveform(stream);
            startRecording();
            updateOrbState('active');
        }

        function initializeWaveform(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const microphone = audioContext.createMediaStreamSource(stream);

            microphone.connect(analyser);
            analyser.fftSize = 256;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function updateWaveform() {
                if (!analyser) return;

                animationFrameId = requestAnimationFrame(updateWaveform);

                analyser.getByteFrequencyData(dataArray);

                const average = dataArray.reduce((a, b) => a + b) / bufferLength;

                waveformBars.forEach((bar, index) => {
                    const value = dataArray[index * 8] || 0;
                    const height = Math.max(20, (value / 255) * 150);
                    bar.style.height = `${height}px`;
                });

                if (!isMuted) {
                    if (average < VOICE_THRESHOLD) {
                        statusMessage.textContent = 'No voice detected';
                    } else {
                        statusMessage.textContent = '';
                    }
                }
            }

            updateWaveform();
        }

        function startRecording() {
            if (!mediaStream) return;

            chunkCounter = 0;
            transcription.textContent = '';
            transcription.classList.remove('empty');
            isRecording = true;

            startNewRecordingSegment();
        }

        function startNewRecordingSegment() {
            if (!isRecording || isMuted) return;

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }

            mediaRecorder = new MediaRecorder(mediaStream);
            accumulatedChunks = [];

            console.log('[MediaRecorder] Starting new recording segment');

            mediaRecorder.addEventListener('dataavailable', (event) => {
                console.log(`[MediaRecorder] dataavailable event fired: size=${event.data.size} bytes, state=${mediaRecorder.state}`);

                if (event.data.size > 0) {
                    accumulatedChunks.push(event.data);
                }
            });

            mediaRecorder.addEventListener('stop', async () => {
                console.log(`[MediaRecorder] stop event fired, accumulated ${accumulatedChunks.length} chunks`);

                if (accumulatedChunks.length > 0 && isRecording && !isMuted) {
                    const completeBlob = new Blob(accumulatedChunks, { type: 'audio/webm' });
                    console.log(`[MediaRecorder] Created complete blob: size=${completeBlob.size} bytes`);
                    await sendChunkForTranscription(completeBlob);

                    setTimeout(startNewRecordingSegment, 0);
                }
            });

            mediaRecorder.start();

            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log('[MediaRecorder] Stopping after 3 seconds');
                    mediaRecorder.stop();
                }
            }, 3000);
        }

        async function sendChunkForTranscription(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'chunk.webm');
            formData.append('chunk_index', chunkCounter);
            formData.append('session_id', sessionId);

            const currentChunkIndex = chunkCounter;
            chunkCounter++;

            console.log(`[Chunk ${currentChunkIndex}] Sending chunk to server: size=${audioBlob.size} bytes`);

            try {
                console.log(`[Chunk ${currentChunkIndex}] Fetch started`);
                const response = await fetch('/transcribe-live', {
                    method: 'POST',
                    body: formData
                });

                console.log(`[Chunk ${currentChunkIndex}] Response received, starting to read stream`);

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        console.log(`[Chunk ${currentChunkIndex}] Stream complete`);
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));
                            console.log(`[Chunk ${currentChunkIndex}] Received event:`, data);

                            if (data.type === 'metadata') {
                                if (currentChunkIndex === 0) {
                                    updateMetadata(data.language, data.duration || 0);
                                }
                            } else if (data.type === 'segment') {
                                console.log(`[Chunk ${currentChunkIndex}] Appending text: "${data.text}"`);
                                appendTranscription(data.text);
                            } else if (data.type === 'error') {
                                console.error(`[Chunk ${currentChunkIndex}] Transcription error:`, data.message);
                            }
                        }
                    }
                }

            } catch (error) {
                console.error(`[Chunk ${currentChunkIndex}] Error sending chunk:`, error);
            }
        }

        function appendTranscription(text) {
            console.log(`[appendTranscription] Called with text: "${text}"`);
            console.log(`[appendTranscription] Current content: "${transcription.textContent}"`);
            console.log(`[appendTranscription] Has 'empty' class: ${transcription.classList.contains('empty')}`);

            if (transcription.classList.contains('empty')) {
                transcription.classList.remove('empty');
                transcription.textContent = '';
            }
            transcription.textContent += ' ' + text;

            console.log(`[appendTranscription] New content: "${transcription.textContent}"`);
            transcription.scrollTop = transcription.scrollHeight;
        }

        function updateMetadata(language, duration) {
            metadata.textContent = `Language: ${language} • ${duration.toFixed(2)}s`;
        }

        function updateOrbState(state) {
            orb.setAttribute('data-state', state);

            if (state === 'active') {
                orb.setAttribute('aria-label', 'Microphone active, click to mute');
            } else if (state === 'muted') {
                orb.setAttribute('aria-label', 'Microphone muted, click to unmute');
            }
        }

        async function toggleMute() {
            if (!isInitialized) {
                await requestMicrophonePermission();
                return;
            }

            isMuted = !isMuted;

            if (isMuted) {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                isRecording = false;
                updateOrbState('muted');
                statusMessage.textContent = 'Muted';
                statusMessage.style.color = '#f5576c';
            } else {
                isRecording = true;
                startNewRecordingSegment();
                updateOrbState('active');
                statusMessage.textContent = '';
                statusMessage.style.color = '#666';
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        orb.addEventListener('click', toggleMute);

        orb.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                toggleMute();
            }
        });

        window.addEventListener('beforeunload', () => {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext) {
                audioContext.close();
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
